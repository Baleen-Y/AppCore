//
//  APCScheduleImporter.m
//  APCAppCore
//
//  Copyright (c) 2015, Apple Inc. All rights reserved. 
//  
//  Redistribution and use in source and binary forms, with or without modification,
//  are permitted provided that the following conditions are met:
//  
//  1.  Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//  
//  2.  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation and/or 
//  other materials provided with the distribution. 
//  
//  3.  Neither the name of the copyright holder(s) nor the names of any contributors 
//  may be used to endorse or promote products derived from this software without 
//  specific prior written permission. No license is granted to the trademarks of 
//  the copyright holders even if such marks are included in this software. 
//  
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
//  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
//  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
//

#import "APCScheduleImporter.h"
#import <CoreData/CoreData.h>
#import <ResearchKit/ResearchKit.h>
#import "APCCompletedOneTimeTaskFilter.h"
#import "APCMatchingScheduleFilter.h"
#import "APCUniqueTaskIdFilter.h"
#import "APCGenericSurveyTaskViewController.h"
#import "APCLog.h"
#import "APCSchedule+AddOn.h"
#import "APCScheduleDebugPrinter.h"
#import "APCScheduleStartDateFilter.h"
#import "APCScheduleFilter.h"
#import "APCExistingTaskFilter.h"
#import "APCMatchingSourceFilter.h"
#import "APCScheduleSourceFilter.h"
#import "APCScheduleTaskMap.h"
#import "APCScheduleTaskMapEntry.h"
#import "APCScheduleInMapFilter.h"
#import "APCTask+AddOn.h"
#import "APCTask+Bridge.h"
#import "NSDate+Helper.h"
#import "NSError+APCAdditions.h"
#import "NSManagedObject+APCHelper.h"
#import "SBBSchedule+APCHelper.h"



// ---------------------------------------------------------
#pragma mark - Constants
// ---------------------------------------------------------

/**
 Controls whether we compute and show (very) detailed debugging
 printouts.  This will always be NO in a release build.
 */
static BOOL const kAPCShowDebugPrintouts = YES;

/**
 Error codes and messages generated by this class.
 */
typedef enum : NSUInteger {
    APCErrorCouldntFindSurveyFileCode,
    APCErrorInboundListOfSchedulesAndTasksIssuesCode,
    APCErrorLoadingNativeBridgeSurveyObjectCode,
    APCErrorLoadingSurveyFileCode,
    APCErrorParsingSurveyContentCode,
    APCErrorSavingEverythingCode
}   APCError;

static NSString * const APCErrorDomain                                              = @"APCErrorDomainImportTasksAndSchedules";
static NSString * const APCErrorCouldntFindSurveyFileReason                         = @"Can't Find Survey File";
static NSString * const APCErrorCouldntFindSurveyFileSuggestion                     = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesReason          = @"Inbound list of schedules and task have issues";
static NSString * const APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion      = @"Inbound list of schedules and task ID's or versions conflict.";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectReason               = @"Can't Find Survey File";
static NSString * const APCErrorLoadingNativeBridgeSurveyObjectSuggestion           = @"We couldn't find the specified survey file on the phone.  Did you misspell the filename, perhaps?";
static NSString * const APCErrorLoadingSurveyFileReason                             = @"There was an error serializing the contents of a survey file";
static NSString * const APCErrorLoadingSurveyFileSuggestion                         = @"There was an error serializing the contents of a survey file. ";
static NSString * const APCErrorParsingSurveyContentReason                          = @"There was an error parsing the contents of a survey file";
static NSString * const APCErrorParsingSurveyContentSuggestion                      = @"There was an error parsing the contents of a survey file.";
static NSString * const APCErrorSavingEverythingReason                              = @"Error Saving New Schedules";
static NSString * const APCErrorSavingEverythingSuggestion                          = @"There was an error attempting to save the new schedules.";


/**
 Keys and special values in the JSON dictionaries representing
 tasks and schedules.
 */
static NSString * const kScheduleDelayKey                      = @"delay";
static NSString * const kScheduleEndDateKey                    = @"endOn";
static NSString * const kScheduleExpiresKey                    = @"expires";
static NSString * const kScheduleIDValueLocallyGeneratedPrefix = @"autogenerated";
static NSString * const kScheduleIntervalKey                   = @"interval";
static NSString * const kScheduleListOfTasksKey                = @"tasks";
static NSString * const kScheduleMaxCountKey                   = @"maxCount";
static NSString * const kScheduleNotesKey                      = @"notes";
static NSString * const kScheduleReminderMessageKey            = @"reminderMessage";
static NSString * const kScheduleReminderOffsetKey             = @"reminderOffset";
static NSString * const kScheduleShouldRemindKey               = @"shouldRemind";
static NSString * const kScheduleStartDateKey                  = @"startOn";
static NSString * const kScheduleStringKey                     = @"scheduleString";
static NSString * const kScheduleTimesOfDayKey                 = @"times";
static NSString * const kScheduleTypeKey                       = @"scheduleType";
static NSString * const kScheduleTypeValueOnce                 = @"once";
static NSString * const kTaskClassNameKey                      = @"taskClassName";
static NSString * const kTaskCompletionTimeStringKey           = @"taskCompletionTimeString";
static NSString * const kTaskFileNameKey                       = @"taskFileName";
static NSString * const kTaskIDKey                             = @"taskID";
static NSString * const kTaskIsOptionalKey                     = @"optional";
static NSString * const kTaskSortStringKey                     = @"sortString";
static NSString * const kTaskTitleKey                          = @"taskTitle";
static NSString * const kTaskTypeKey                           = @"taskType";
static NSString * const kTaskTypeValueSurvey                   = @"survey";
static NSString * const kTaskUrlKey                            = @"taskUrl";
static NSString * const kTaskVersionNumberKey                  = @"version";


/**
 Formats for interpreting a JSON list of time values.
 Filled in during +load.
 */
static NSArray *legalTimeSpecifierFormats = nil;



// ---------------------------------------------------------
#pragma mark - The Class Body
// ---------------------------------------------------------


@implementation APCScheduleImporter

/**
 Sets global, static values the first time anyone calls this category.

 By definition, this method is called once per category, in a thread-safe
 way, the first time the category is sent a message -- basically, the first
 time we refer to any method declared in that category.

 Documentation:  the key sentence is actually in the documentation for
 +initialize:  "initialize is invoked only once per class. If you want
 to perform independent initialization for the class and for categories
 of the class, you should implement +load methods."

 Useful resources:
 -  http://stackoverflow.com/q/13326435
 -  https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/clm/NSObject/load
 -  https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/occ/clm/NSObject/initialize
 */
+ (void) load
{
    legalTimeSpecifierFormats = @[@"H",
                                  @"HH",
                                  @"HH:mm",
                                  @"HH:mm:SS",
                                  @"HH:mm:SS.sss"
                                  ];
}


// ---------------------------------------------------------
#pragma mark - The Main Import Method
// ---------------------------------------------------------

/**
 Analyzes the inbound schedules and tasks, compares them with the existing and
 running schedules and tasks, and figures out which to import, update,
 terminate, or delete.

 This is the main "import" method -- the place where all tasks and schedules
 get into the system.

 This method runs all imported and currently-running schedules through a set of
 filters.  When the schedules pop out the bottom of the filters, we've sorted
 them into stuff to act on in different ways.  The filters embody the logic in
 the decision tree below.
 
 Each filter is a subclass of APCScheduleFilter.  Please see that class for a
 general description of how filters work.


 ---------- The Business Rules ----------
 
 The following is a decision tree:  a bunch of "if" statements, showing what to
 do with a given subset of the inbound or currently-running schedules.  The
 nodes of the tree represent splitting a set of schedules into 2 or more
 subsets, using filters that represent those "if" statements.  The leaf nodes
 of the tree are the actions we'll take on those lowest-level subsets.

 - NEW schedules
    - schedules that USE THE SAME TASK IDS as other inbound schedules
        - (delete)

    - the FIRST schedules we find which control a given task ID
        - schedules controlling only BRAND-NEW tasks
            - (keep)

        - all other schedules:  schedules for EXISTING tasks, or which control both existing and new tasks
            - schedules for COMPLETED, ONE-TIME tasks
                - (delete)

            - schedules for ALL OTHER task types ("incomplete" tasks)
                - schedules from the SAME source as the most recent schedule controlling each schedule's task
                    - schedules trying to control ACTIVE tasks
                        - schedules which are IDENTICAL to those active schedules
                            - (delete)
                        - all other schedules:  schedules which DIFFER from those active schedules
                            - (keep)
 
                    - all other schedules:  schedules trying to control INACTIVE tasks
                        - (keep)

                - all other schedules:  schedules from a DIFFERENT source as the most recent one controlling that task
                    - (FUTURE PLANNING #1.  We'll do these three "FUTURE PLANNING" sections at the same time.)

                    - schedules from the SERVER
						- schedules for CURRENTLY ACTIVE tasks
                            - schedules which are IDENTICAL to those active tasks' schedules
                                - (delete)
                            - all other schedules:  schedules which DIFFER from those active tasks' schedules
                                - (keep)

                        - all other schedules:  schedules for INACTIVE tasks
							- (keep)

                    - schedules NOT from the server
						- (delete)

 - CURRENTLY ACTIVE schedules
    - from THIS source (whatever source launched this method)
		- with task ids that WERE mentioned in this download
			- identical schedules (as incoming)
				- (keep, i.e., ignore)

			- different schedules (from incoming)
				- downloaded in past
					- (terminate tonight)
				- downloaded today
					- (delete)
				- downloaded in future
					- (keep, i.e., ignore)

		- without task ids that were NOT mentioned in this download
			- (terminate tonight)

    - all other schedules:  from OTHER sources
        - (FUTURE PLANNING #2.  We'll do these three "FUTURE PLANNING" sections at the same time.)

        - schedules from the SERVER
            - (ignore; handled earlier)

        - all other schedules:  NOT from the server
            - schedules being OVERTAKEN by schedules from the server
                - downloaded in past
                    - (TBD)
                - downloaded today
                    - (TBD)
                - downloaded in future
                    - (TBD)

			- all other schedules:  NOT being overtaken by server schedules
				- (keep, i.e., ignore)

- existing tasks to be updated:
    - (FUTURE PLANNING #3.  We'll do these three "FUTURE PLANNING" sections at the same time.)

 */
- (void) processSchedulesAndTasks: (NSArray *) arrayOfSchedulesAndTasks
                       fromSource: (APCScheduleSource) scheduleSource
                     usingContext: (NSManagedObjectContext *) context
              scheduleQueryEngine: (id <APCScheduleQueryEngine>) queryEngine
                       importDate: (NSDate *) importDate
                   returningError: (NSError * __autoreleasing *) errorToReturn
{
    // -----------------------------------------------------
    // Setup
    // -----------------------------------------------------

    NSDate *today = importDate;
    NSDate *relativeTimeBeforeStarting = [NSDate date];
    NSMutableString *printout = nil;
    NSError *finalErrorFromThisMethod = nil;
    NSError *errorFetchingCurrentSchedules = nil;
    APCScheduleDebugPrinter *printer = nil;

#if DEBUG
    if (kAPCShowDebugPrintouts)
    {
        printout = [NSMutableString new];
        printer = [APCScheduleDebugPrinter new];
    }
#endif


    // -----------------------------------------------------
    // Query and Import
    // -----------------------------------------------------

    NSArray *activeScheduleArray = [queryEngine querySchedulesActiveOnDayOfDate: today
                                                                     fromSource: scheduleSource
                                                                      inContext: context
                                                                 returningError: & errorFetchingCurrentSchedules];

    NSArray *newScheduleArray = [self createSchedulesAndUpdateTasksFromIncomingData: arrayOfSchedulesAndTasks
                                                                          forSource: scheduleSource
                                                                          inContext: context
                                                                    usingImportDate: importDate];

    NSMutableSet *activeSchedules = [NSMutableSet setWithArray: activeScheduleArray];
    NSMutableSet *newSchedules    = [NSMutableSet setWithArray: newScheduleArray];

    if (activeScheduleArray == nil)
    {
        finalErrorFromThisMethod = errorFetchingCurrentSchedules;
    }


    // -----------------------------------------------------
    // Filters and metadata
    // -----------------------------------------------------

    NSSet *newTaskIds = [APCSchedule extractTaskIdsFromSchedules: newSchedules];

    APCScheduleTaskMap *activeScheduleMap = [[APCScheduleTaskMap alloc] initWithSetOfSchedules: activeSchedules];
    APCScheduleTaskMap *newScheduleMap    = [[APCScheduleTaskMap alloc] initWithSetOfSchedules: newSchedules];
    APCScheduleTaskMap *recentScheduleMap = [self queryMostRecentOwnersForTaskIds: newTaskIds usingContext: context];
    
    APCUniqueTaskIdFilter         *uniqueTaskFilter                     = [APCUniqueTaskIdFilter new];
    APCExistingTaskFilter         *existingTaskFilter                   = [APCExistingTaskFilter new];
    APCCompletedOneTimeTaskFilter *completedOneTimeTaskFilter           = [APCCompletedOneTimeTaskFilter new];
    APCScheduleSourceFilter       *scheduleSourceFilter                 = [APCScheduleSourceFilter new];
    APCMatchingSourceFilter       *matchingSourceFilter                 = [APCMatchingSourceFilter new];
    APCScheduleInMapFilter        *newTasksAreActiveFilter              = [APCScheduleInMapFilter new];
    APCMatchingScheduleFilter     *newMatchingScheduleFilter            = [APCMatchingScheduleFilter new];
    APCMatchingScheduleFilter     *activeSchedulesIdenticalToNewFilter  = [APCMatchingScheduleFilter new];
    APCScheduleInMapFilter        *activeTasksAreNewFilter              = [APCScheduleInMapFilter new];
    APCScheduleStartDateFilter    *startDateFilter                      = [APCScheduleStartDateFilter new];



    // -----------------------------------------------------
    // Analyze
    // -----------------------------------------------------

    /*
     This section implements the decision tree in the documentation above.
     When you read this, it might help to split the screen, with the documentation
     on one side and this code on the other, so you can see how each filter maps
     to decision in the tree.
     */

    //
    // Decide what to do with incoming schedules.
    //

    [uniqueTaskFilter            split: newSchedules];
    [existingTaskFilter          split: uniqueTaskFilter.passed            withMap: recentScheduleMap];
    [completedOneTimeTaskFilter  split: existingTaskFilter.passed          withMap: recentScheduleMap];
    [matchingSourceFilter        split: completedOneTimeTaskFilter.failed  withMap: recentScheduleMap];
    [newTasksAreActiveFilter     split: matchingSourceFilter.passed        withMap: activeScheduleMap];
    [newMatchingScheduleFilter   split: newTasksAreActiveFilter.passed     withMap: activeScheduleMap];


    //
    // Decide what to do with active schedules.
    //

    [scheduleSourceFilter                split: activeSchedules                             withSource: scheduleSource];
    [activeTasksAreNewFilter             split: scheduleSourceFilter.passed                 withMap: newScheduleMap];
    [activeSchedulesIdenticalToNewFilter split: activeTasksAreNewFilter.passed              withMap: newScheduleMap];
    [startDateFilter                     split: activeSchedulesIdenticalToNewFilter.failed  withDate: today];



    // -----------------------------------------------------
    // Print the analysis so far, before we change some of those objects
    // -----------------------------------------------------

    [printout appendFormat:
     @"\n\n======================= new batch of schedules from %@ at %@ =======================\n",
     NSStringFromAPCScheduleSource (scheduleSource),
     [printer stringFromDate: relativeTimeBeforeStarting]];

    NSString *sourceName = NSStringFromAPCScheduleSource (scheduleSource);

    [printout appendString: @"--------\nAnalyzing incoming schedules\n--------\n"];

    [printer printSetOfSchedules: newSchedules                       intoMutableString: printout  withLabel: @"New schedules"];
    [printer printSetOfSchedules: uniqueTaskFilter.passed            intoMutableString: printout  withLabel: @"...without duplicate task IDs (we'll keep processing these)"];
    [printer printSetOfSchedules: uniqueTaskFilter.failed            intoMutableString: printout  withLabel: @"...with duplicate task IDs (we'll delete these)"];
    [printer printSetOfSchedules: existingTaskFilter.failed          intoMutableString: printout  withLabel: @"...with brand-new tasks"];
    [printer printSetOfSchedules: existingTaskFilter.passed          intoMutableString: printout  withLabel: @"...with existing tasks"];
    [printer printSetOfSchedules: completedOneTimeTaskFilter.passed  intoMutableString: printout  withLabel: @"...for existing, completed, one-time tasks (we'll delete these)"];
    [printer printSetOfSchedules: completedOneTimeTaskFilter.failed  intoMutableString: printout  withLabel: @"...for not-yet-completed tasks (we'll keep processing these)"];
    [printer printSetOfSchedules: matchingSourceFilter.passed        intoMutableString: printout  withLabel: @"...matching existing sources for not-yet-completed tasks"];
    [printer printSetOfSchedules: matchingSourceFilter.failed        intoMutableString: printout  withLabel: @"...NOT matching existing sources for not-yet-completed tasks"];
    [printer printSetOfSchedules: newTasksAreActiveFilter.passed     intoMutableString: printout  withLabel: @"...(matching existing sources, not yet completed) for active tasks"];
    [printer printSetOfSchedules: newTasksAreActiveFilter.failed     intoMutableString: printout  withLabel: @"...(matching existing sources, not yet completed) for inactive tasks"];
    [printer printSetOfSchedules: newMatchingScheduleFilter.passed   intoMutableString: printout  withLabel: @"...which duplicate active schedules (we'll delete these)"];
    [printer printSetOfSchedules: newMatchingScheduleFilter.failed   intoMutableString: printout  withLabel: @"...which don't duplicate active schedules (we'll keep these)"];


    [printout appendString: @"--------\nAnalyzing running schedules\n--------\n"];

    [printer printSetOfSchedules: activeSchedules                            intoMutableString: printout  withLabel: @"Active schedules"];
    [printer printSetOfSchedules: scheduleSourceFilter.passed                intoMutableString: printout  withLabel: [NSString stringWithFormat: @"...from this source, %@", sourceName]];
    [printer printSetOfSchedules: scheduleSourceFilter.failed                intoMutableString: printout  withLabel: @"...from other sources"];
    [printer printSetOfSchedules: activeTasksAreNewFilter.passed             intoMutableString: printout  withLabel: @"...from this source with new schedules"];
    [printer printSetOfSchedules: activeTasksAreNewFilter.failed             intoMutableString: printout  withLabel: @"...from this source without new schedules"];
    [printer printSetOfSchedules: activeSchedulesIdenticalToNewFilter.passed intoMutableString: printout  withLabel: @"...identical to new schedules"];
    [printer printSetOfSchedules: activeSchedulesIdenticalToNewFilter.failed intoMutableString: printout  withLabel: @"...different from new schedules"];
    [printer printSetOfSchedules: startDateFilter.before                     intoMutableString: printout  withLabel: @"...downloaded in the past"];
    [printer printSetOfSchedules: startDateFilter.during                     intoMutableString: printout  withLabel: @"...downloaded sometime today (we'll delete these)"];
    [printer printSetOfSchedules: startDateFilter.after                      intoMutableString: printout  withLabel: @"...downloaded in the future"];



    // -----------------------------------------------------
    // Do
    // -----------------------------------------------------

    /*
     By the time we get here, we should have:
     - stuff to leave as-is:  currently running and OK that way, or newly imported and accepted
     - stuff to delete:       imported earlier today; or illegal incoming stuff
     - stuff to terminate:    previous schedules for the same tasks
     */

    [self terminateSchedules: startDateFilter.before  asOfDate: today.dayBefore];

    [self deleteSchedulesButNotTasks: uniqueTaskFilter.failed           inContext: context];
    [self deleteSchedulesButNotTasks: completedOneTimeTaskFilter.passed inContext: context];
    [self deleteSchedulesButNotTasks: newMatchingScheduleFilter.passed  inContext: context];
    [self deleteSchedulesButNotTasks: startDateFilter.during            inContext: context];

    

    // -----------------------------------------------------
    // Save
    // -----------------------------------------------------

    if (! context.hasChanges)
    {
        [printout appendString: @"\n...which means, all told, there's nothing to save.  We're done.\n\n"];
    }
    else
    {
        NSManagedObject *anySaveableObject = newSchedules.anyObject;
        NSError *errorSavingEverything = nil;
        BOOL saved = [anySaveableObject saveToPersistentStore: & errorSavingEverything];

        if (! saved)
        {
            finalErrorFromThisMethod = [NSError errorWithCode: APCErrorSavingEverythingCode
                                                       domain: APCErrorDomain
                                                failureReason: APCErrorSavingEverythingReason
                                           recoverySuggestion: APCErrorSavingEverythingSuggestion
                                                  nestedError: errorSavingEverything];
        }
    }



    // -----------------------------------------------------
    // Summarize and print
    // -----------------------------------------------------

    // Summarize
    NSArray *currentSchedulesAfterImport = [queryEngine querySchedulesActiveOnDayOfDate: today
                                                                             fromSource: scheduleSource
                                                                              inContext: context
                                                                         returningError: & errorFetchingCurrentSchedules];

    [printout appendString: @"--------\nResults\n--------\n"];

    [printer printArrayOfSchedules: currentSchedulesAfterImport
                         withLabel: @"Current schedules after import"
                 intoMutableString: printout];

    [printer printSetOfSchedules: startDateFilter.before
               intoMutableString: printout
                       withLabel: @"Terminated schedules"];


    // Print
    NSDate *relativeTimeAtEnd = [NSDate date];
    NSTimeInterval totalTime = [relativeTimeAtEnd timeIntervalSinceDate: relativeTimeBeforeStarting];
    [printout appendFormat: @"\nTotal time: %f seconds\n", totalTime];
    
    [printout appendFormat:
     @"======================= end batch of schedules from %@ at %@ =======================\n\n",
     NSStringFromAPCScheduleSource (scheduleSource),
     [printer stringFromDate: relativeTimeBeforeStarting]];
    
    NSLog (@"%@", printout);



    // -----------------------------------------------------
    // Done!
    // -----------------------------------------------------

    if (errorToReturn != nil)
    {
        * errorToReturn = finalErrorFromThisMethod;
    }
}



// ---------------------------------------------------------
#pragma mark - Delete and Disable
// ---------------------------------------------------------

- (void) terminateSchedules: (NSSet *) schedulesToTerminate
                   asOfDate: (NSDate *) terminationDate
{
    NSDate *endOfDay = terminationDate.endOfDay;   // 23:59:59

    for (APCSchedule *schedule in schedulesToTerminate)
    {
        schedule.effectiveEndDate = endOfDay;
    }
}

- (void) deleteSchedulesButNotTasks: (NSSet *) schedulesToDelete
                          inContext: (NSManagedObjectContext *) context
{
    for (APCSchedule *schedule in schedulesToDelete)
    {
        [context deleteObject: schedule];
    }
}



// ---------------------------------------------------------
#pragma mark - Create
// ---------------------------------------------------------

- (NSArray *) createSchedulesAndUpdateTasksFromIncomingData: (NSArray *) incomingSchedulesAndTasks
                                                  forSource: (APCScheduleSource) scheduleSource
                                                  inContext: (NSManagedObjectContext *) context
                                            usingImportDate: (NSDate *) importDate
{
    NSMutableArray *schedules = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingSchedulesAndTasks)
    {
        APCSchedule *schedule = [self createOneScheduleAndItsTasksFromJsonData: scheduleData
                                                                    fromSource: scheduleSource
                                                                  usingContext: context
                                                                 andImportDate: importDate];

        [schedules addObject: schedule];
    }

    return schedules;
}

- (APCSchedule *) createOneScheduleAndItsTasksFromJsonData: (NSDictionary *) inboundScheduleData
                                                fromSource: (APCScheduleSource) scheduleSource
                                              usingContext: (NSManagedObjectContext *) context
                                             andImportDate: (NSDate *) importDate
{
    APCSchedule *schedule   = [APCSchedule newObjectForContext: context];
    schedule.scheduleSource = @(scheduleSource);

    NSMutableDictionary *scheduleData = inboundScheduleData.mutableCopy;


    //
    // Pre-import data validation.
    //

    id requestedStartDate = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    id requestedEndDate   = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    id timesOfDay         = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey] ];

    if ([requestedStartDate isKindOfClass: [NSString class]])
    {
        requestedStartDate = [NSDate dateWithISO8601String: requestedStartDate];
    }

    if ([requestedEndDate isKindOfClass: [NSString class]])
    {
        requestedEndDate = [NSDate dateWithISO8601String: requestedEndDate];
    }

    if ([timesOfDay isKindOfClass: [NSArray class]])
    {
        timesOfDay = [self serializedTimesOfDayStringFromISO8601TimesOfDayInArray: timesOfDay];
    }

    scheduleData [kScheduleStartDateKey]  = [self nullIfNil: requestedStartDate];
    scheduleData [kScheduleEndDateKey]    = [self nullIfNil: requestedEndDate];
    scheduleData [kScheduleTimesOfDayKey] = [self nullIfNil: timesOfDay];



    //
    // Copy the data into our local object.
    //

    schedule.delay                  = [self nilIfNull: scheduleData [kScheduleDelayKey]];
    schedule.endsOn                 = [self nilIfNull: scheduleData [kScheduleEndDateKey]];
    schedule.expires                = [self nilIfNull: scheduleData [kScheduleExpiresKey]];
    schedule.interval               = [self nilIfNull: scheduleData [kScheduleIntervalKey]];
    schedule.maxCount               = [self nilIfNull: scheduleData [kScheduleMaxCountKey]];
    schedule.notes                  = [self nilIfNull: scheduleData [kScheduleNotesKey]];
    schedule.reminderMessage        = [self nilIfNull: scheduleData [kScheduleReminderMessageKey]];         // if from Sage:  "label"
    schedule.reminderOffset         = [self nilIfNull: scheduleData [kScheduleReminderOffsetKey]];
    schedule.scheduleString         = [self nilIfNull: scheduleData [kScheduleStringKey]];
    schedule.scheduleType           = [self nilIfNull: scheduleData [kScheduleTypeKey]];
    schedule.shouldRemind           = [self nilIfNull: scheduleData [kScheduleShouldRemindKey]];
    schedule.startsOn               = [self nilIfNull: scheduleData [kScheduleStartDateKey]];
    schedule.timesOfDay             = [self nilIfNull: scheduleData [kScheduleTimesOfDayKey]];


    //
    // Add data validation, defaults, and calculations.
    //

    /*
     Start date:  this morning, at midnight, whenever "this
     morning" is.  NOT the app-installation time; that might
     be months ago, which would not reflect the user's
     experience of this schedule -- it didn't exist back
     then.
     */
    NSDate *beginningOfTime = importDate.startOfDay;

    if (schedule.startsOn == nil)
    {
        schedule.startsOn = beginningOfTime;
    }


    /*
     Effective start date = start date + delay.  Then round to midnight that
     morning.  See this -compute method for details.
     */
    schedule.effectiveStartDate = [schedule computeDelayedStartDateFromDate: schedule.startsOn];


    /*
     Effective end date:  the end date + the expiration period, then round to
     the end of that day.  See this -compute method for details.
     */
    schedule.effectiveEndDate = [schedule computeExpirationDateForScheduledDate: schedule.endsOn];


    //
    // Creating Tasks
    //
    NSArray *tasks = scheduleData [kScheduleListOfTasksKey];

    for (NSDictionary *taskData in tasks)
    {
        APCTask *task = [self createOrUpdateTaskFromJsonData: taskData
                                                   inContext: context];
        if (task)
        {
            [schedule addTasksObject: task];
        }
    }


    //
    // Done!
    //
    return schedule;
}

/**
 When we get data from a file or from the server, we first convert it to a set
 of dictionaries.  Each dictionary contains one Schedule.  That Schedule
 contains a list of the Tasks the schedule should manage.  Then we loop through
 those Schedules, creating each one.  Within that "create schedule" method, we
 then loop through all the Tasks it's supposed to manage, and create each of
 THOSE.  This method does that part: creates a single Task, when we're looping
 through the list of tasks attached to inbound schedule data.
 */
- (APCTask *) createOrUpdateTaskFromJsonData: (NSDictionary *) taskData
                                   inContext: (NSManagedObjectContext *) context
{
    APCTask  *task              = nil;
    NSString *taskId            = [self nilIfNull: taskData [kTaskIDKey]];
    NSNumber *taskVersionNumber = [self nilIfNull: taskData [kTaskVersionNumberKey]];

    NSSet *tasks = [APCTask querySavedTasksWithTaskIds: [NSSet setWithObject: taskId]
                                          usingContext: context];

    if (tasks)
    {
        task = tasks.anyObject;
    }

    if (task == nil)
    {
        task = [APCTask newObjectForContext: context];
        task.taskID = taskId;
        task.taskVersionNumber = taskVersionNumber;
    }

    [self updateTask: task
            withData: taskData];

    return task;
}

- (void) updateTask: (APCTask *) task
           withData: (NSDictionary *) taskData
{
    //
    // Update the task with potentially new data
    // (or add it for the first time, if we're creating a task).
    //
    task.taskHRef                   = [self nilIfNull: taskData [kTaskUrlKey]];                     // Sage-only?
    task.taskTitle                  = [self nilIfNull: taskData [kTaskTitleKey]];                   // sage and us
    task.sortString                 = [self nilIfNull: taskData [kTaskSortStringKey]];              // us-only, for now
    task.taskClassName              = [self nilIfNull: taskData [kTaskClassNameKey]];               // sage and us, because we add to sage
    task.taskCompletionTimeString   = [self nilIfNull: taskData [kTaskCompletionTimeStringKey]];    // us-only?
    task.taskContentFileName        = [self nilIfNull: taskData [kTaskFileNameKey]];                // us-only?
    task.taskIsOptional             = [self nilIfNull: taskData [kTaskIsOptionalKey]];              // us for now, Sage eventually?


    if ([task.taskTitle stringByTrimmingCharactersInSet: [NSCharacterSet whitespaceAndNewlineCharacterSet]].length == 0)
    {
        APCLogDebug (@"\n-------------\nWARNING!  About to create a Task with an empty title!  taskData and task are:  \n%@\n%@\n----------------", taskData, task);
    }

    if (task.taskContentFileName)
    {
        id <ORKTask> survey = [self surveyFromFileBaseName: task.taskContentFileName];
        
        if (survey)
        {
            task.rkTask = survey;
        }
    }
}

- (BOOL) updateTasksInSchedules: (NSArray *) schedulesThatAreAlreadyPerfect
               fromIncomingData: (NSArray *) incomingScheduleAndTaskData
{
    BOOL result = NO;

    for (APCSchedule *schedule in schedulesThatAreAlreadyPerfect)
    {
        for (APCTask *task in schedule.tasks)
        {
            NSString *taskId = task.taskID;
            NSNumber *taskVersion = task.taskVersionNumber;
            NSDictionary *taskData = [self extractTaskDataFromIncomingListOfSchedulesAndTasks: incomingScheduleAndTaskData
                                                                               withThisTaskId: taskId
                                                                               andThisVersion: taskVersion];
            [self updateTask: task
                    withData: taskData];
        }
    }

    return result;
}

- (id <ORKTask>) surveyFromFileBaseName: (NSString *) surveyContentFileBaseName
{
    id <ORKTask> rkSurvey = nil;

    NSString *surveyFilePath = [[NSBundle mainBundle] pathForResource: surveyContentFileBaseName
                                                               ofType: kAPCFileExtension_JSON];

    if (! surveyFilePath)
    {
        NSString *fullFileName = [NSString stringWithFormat: @"%@.%@", surveyContentFileBaseName, kAPCFileExtension_JSON];

        NSError *errorFindingSurveyFile = [NSError errorWithCode: APCErrorCouldntFindSurveyFileCode
                                                          domain: APCErrorDomain
                                                   failureReason: APCErrorCouldntFindSurveyFileReason
                                              recoverySuggestion: APCErrorCouldntFindSurveyFileSuggestion
                                                 relatedFilePath: fullFileName
                                                      relatedURL: nil
                                                     nestedError: nil];

        APCLogError2 (errorFindingSurveyFile);
    }

    else
    {
        NSError *errorLoadingSurveyFile = nil;
        NSData *jsonData = [NSData dataWithContentsOfFile: surveyFilePath
                                                  options: 0
                                                    error: & errorLoadingSurveyFile];

        if (! jsonData)
        {
            NSError *error = [NSError errorWithCode: APCErrorLoadingSurveyFileCode
                                             domain: APCErrorDomain
                                      failureReason: APCErrorLoadingSurveyFileReason
                                 recoverySuggestion: APCErrorLoadingSurveyFileSuggestion
                                        nestedError: errorLoadingSurveyFile];

            APCLogError2 (error);
        }

        else
        {
            NSError *errorParsingSurveyContent = nil;
            NSDictionary *surveyContent = [NSJSONSerialization JSONObjectWithData: jsonData
                                                                          options: 0
                                                                            error: & errorParsingSurveyContent];
            if (! surveyContent)
            {
                NSError *error = [NSError errorWithCode: APCErrorParsingSurveyContentCode
                                                 domain: APCErrorDomain
                                          failureReason: APCErrorParsingSurveyContentReason
                                     recoverySuggestion: APCErrorParsingSurveyContentSuggestion
                                            nestedError: errorParsingSurveyContent];

                APCLogError2 (error);
            }

            else
            {
                @try
                {
                    id manager = SBBComponent(SBBSurveyManager);
                    SBBSurvey *survey = [[manager objectManager] objectFromBridgeJSON: surveyContent];
                    rkSurvey = [APCTask rkTaskFromSBBSurvey: survey];
                }
                @catch (NSException *exception)
                {
                    NSError *error = [NSError errorWithCode: APCErrorLoadingNativeBridgeSurveyObjectCode
                                                     domain: APCErrorDomain
                                              failureReason: APCErrorLoadingNativeBridgeSurveyObjectReason
                                         recoverySuggestion: APCErrorLoadingNativeBridgeSurveyObjectSuggestion
                                            relatedFilePath: surveyFilePath
                                                 relatedURL: nil
                                                nestedError: nil
                                              otherUserInfo: @{ @"exception": exception,
                                                                @"stackTrace": exception.callStackSymbols }];

                    APCLogError2 (error);
                }
                @finally
                {

                }
            }
        }
    }
    
    return rkSurvey;
}



// ---------------------------------------------------------
#pragma mark - Queries
// ---------------------------------------------------------

- (APCScheduleTaskMap *) queryMostRecentOwnersForTaskIds: (NSSet *) taskIds
                                            usingContext: (NSManagedObjectContext *) context
{
    APCScheduleTaskMap *map = [APCScheduleTaskMap new];

    NSSet *tasks = [APCTask querySavedTasksWithTaskIds: taskIds usingContext: context];

    for (APCTask *task in tasks)
    {
        if (task.taskID.length)
        {
            APCSchedule *mostRecentSchedule = task.mostRecentSchedule;

            APCScheduleTaskMapEntry *entry = [[APCScheduleTaskMapEntry alloc] initWithTaskId: task.taskID
                                                                                        task: task
                                                                                    schedule: mostRecentSchedule];

            [map setEntry: entry forTaskId: task.taskID];
        }
    }
    
    return map;
}



// ---------------------------------------------------------
#pragma mark - JSON conversions
// ---------------------------------------------------------

/**
 Convert inbound Sage server data to an NSDictionary of keys we know how to
 look for.

 This lets us use the same method to process data downloaded from the server as
 we do data pulled from a local JSON file.
 */
- (NSDictionary *) extractJsonDataFromIncomingSageSchedule: (SBBSchedule *) sageSchedule
{
    NSNull *null                                    = [NSNull null];
    NSMutableDictionary *scheduleData               = [NSMutableDictionary new];
    NSMutableArray *activities                      = [NSMutableArray new];

    scheduleData [kScheduleReminderMessageKey]      = [self nullIfNil: sageSchedule.label];
    scheduleData [kScheduleTypeKey]                 = [self nullIfNil: sageSchedule.scheduleType];
    scheduleData [kScheduleStartDateKey]            = [self nullIfNil: sageSchedule.startsOn];
    scheduleData [kScheduleStringKey]               = [self nullIfNil: sageSchedule.cronTrigger];
    scheduleData [kScheduleExpiresKey]              = [self nullIfNil: sageSchedule.expires];
    scheduleData [kScheduleEndDateKey]              = [self nullIfNil: sageSchedule.endsOn];
    scheduleData [kScheduleListOfTasksKey]          = activities;

    // As a reminder to get these when Sage has a chance to add them.
    scheduleData [kScheduleIntervalKey]             = null; // [self nullIfNil: sageSchedule.interval];
    scheduleData [kScheduleTimesOfDayKey]           = null; // [self nullIfNil: sageSchedule.times];
    scheduleData [kScheduleMaxCountKey]             = null; // [self nullIfNil: sageSchedule.maxCount];


    for (SBBActivity *activity in sageSchedule.activities)
    {
        NSMutableDictionary *activityData = [NSMutableDictionary new];

        activityData [kTaskTitleKey]            = [self nullIfNil: activity.label];
        activityData [kTaskTypeKey]             = [self nullIfNil: activity.activityType];
        activityData [kTaskIDKey]               = [self nullIfNil: activity.survey.guid];
        activityData [kTaskVersionNumberKey]    = [self nullIfNil: activity.survey.version];
        activityData [kTaskUrlKey]              = [self nullIfNil: activity.ref];
        activityData [kTaskClassNameKey]        = NSStringFromClass ([APCGenericSurveyTaskViewController class]);

        // When we start getting these from Sage, we'll use them.
        // In the mean time, noting them here, because we're using
        // them from our local disk files.
        activityData [kTaskCompletionTimeStringKey] = null;
        activityData [kTaskFileNameKey]             = null;
        activityData [kTaskSortStringKey]           = null;

        [activities addObject: activityData];
    }
    
    return scheduleData;
}

/**
 Crawls through the dictionaries and arrays in the incoming data until it finds
 a task dictionary containing the specified id and version.
 */
- (NSDictionary *) extractTaskDataFromIncomingListOfSchedulesAndTasks: (NSArray *) incomingScheduleAndTaskData
                                                       withThisTaskId: (NSString *) taskId
                                                       andThisVersion: (NSNumber *) taskVersion
{
    NSDictionary *foundTaskData = nil;
    NSMutableArray *taskDataWithSameIdAndVersion = [NSMutableArray new];

    for (NSDictionary *scheduleData in incomingScheduleAndTaskData)
    {
        NSArray *tasksForThisSchedule = scheduleData [kScheduleListOfTasksKey];

        for (NSDictionary *taskData in tasksForThisSchedule)
        {
            NSString *taskIdFromData      = [self nilIfNull: taskData [kTaskIDKey]];
            NSNumber *taskVersionFromData = [self nilIfNull: taskData [kTaskVersionNumberKey]];

            if ([self object1: taskId      equalsObject2: taskIdFromData]      &&
                [self object1: taskVersion equalsObject2: taskVersionFromData] )
            {
                [taskDataWithSameIdAndVersion addObject: taskData];
            }
        }
    }

    if (taskDataWithSameIdAndVersion.count == 0)
    {
        // Truly should never happen, since we got the taskID
        // and version from a previous pass through the data.
    }

    else if (taskDataWithSameIdAndVersion.count == 1)
    {
        // This is what we were expecting.
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }

    else    // .count > 1
    {
        NSError *tooManyTasksWithSameIdAndVersion = [NSError errorWithCode: APCErrorInboundListOfSchedulesAndTasksIssuesCode
                                                                    domain: APCErrorDomain
                                                             failureReason: APCErrorInboundListOfSchedulesAndTasksIssuesReason
                                                        recoverySuggestion: APCErrorInboundListOfSchedulesAndTasksIssuesSuggestion
                                                           relatedFilePath: nil
                                                                relatedURL: nil
                                                               nestedError: nil
                                                             otherUserInfo: @{ kTaskIDKey            : [self nullIfNil: taskId],
                                                                               kTaskVersionNumberKey : [self nullIfNil: taskVersion] }];
        APCLogError2 (tooManyTasksWithSameIdAndVersion);

        // Therefore, this is kinda undefined:
        foundTaskData = taskDataWithSameIdAndVersion.firstObject;
    }
    
    return foundTaskData;
}



// ---------------------------------------------------------
#pragma mark - Default Values
// ---------------------------------------------------------

- (NSDictionary *) defaultScheduleValues
{
    NSNull *null = [NSNull null];

    return @{
             kScheduleTypeKey               : kScheduleTypeValueOnce,
             kScheduleStringKey             : null,
             kTaskIDKey                     : null,
             kScheduleExpiresKey            : null,
             kScheduleDelayKey              : null,
             kScheduleStartDateKey          : null,
             kScheduleEndDateKey            : null,
             };
}

- (NSDictionary *) defaultTaskValues
{
    return @{};
}



// ---------------------------------------------------------
#pragma mark - Serializing times of day
// ---------------------------------------------------------

/*
 These two methods are very similar to a method in APCScheduleIntervalEnumerator.m.
 */

- (NSString *) serializedTimesOfDayStringFromISO8601TimesOfDayInArray: (NSArray *) timesOfDay
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: kAPCDateFormatLocaleEN_US_POSIX];

    NSString *result = nil;
    NSMutableArray *arrayOfValidStrings = [NSMutableArray new];

    if (timesOfDay != nil && [timesOfDay isKindOfClass: [NSArray class]])
    {
        for (id thingy in timesOfDay)
        {
            NSString *inboundTimeString = nil;

            /*
             Allow integers as times of day (3 = 3am, 14 =
             2pm, etc.) The spec only requests ISO 8601
             strings, but I think this will make life
             easier and equally practical, and it doesn't
             cost us much.
             */
            if ([thingy isKindOfClass: [NSNumber class]])
            {
                NSNumber *value = thingy;
                NSUInteger intValue = value.integerValue;
                float floatValue = value.floatValue;
                if (floatValue == (float) intValue &&
                    intValue >= kAPCTimeFirstLegalISO8601HourOfDay &&
                    intValue <= kAPCTimeLastLegalISO8601HourOfDay)
                {
                    inboundTimeString = value.stringValue;
                }
            }

            else if ([thingy isKindOfClass: [NSString class]])
            {
                inboundTimeString = thingy;
            }

            else
            {
                // Ignore all other data types.
            }

            if (inboundTimeString != nil)
            {
                NSDate *date = nil;

                for (NSString *format in legalTimeSpecifierFormats)
                {
                    formatter.dateFormat = format;
                    date = [formatter dateFromString: inboundTimeString];

                    if (date != nil)
                    {
                        break;
                    }
                }

                if (date != nil)
                {
                    [arrayOfValidStrings addObject: inboundTimeString];
                }
            }
        }
    }

    result = [arrayOfValidStrings componentsJoinedByString: @"|"];

    if (result.length == 0)
    {
        result = nil;
    }

    return result;
}

- (NSArray *) deserializedArrayOfDurationsSinceMidnightFromISO8601TimesOfDayString: (NSString *) serializedTimesOfDayString
{
    NSDateFormatter *formatter = [NSDateFormatter new];
    formatter.locale = [NSLocale localeWithLocaleIdentifier: kAPCDateFormatLocaleEN_US_POSIX];

    NSMutableArray *result = [NSMutableArray new];
    NSArray *iso8601TimeStrings = [serializedTimesOfDayString componentsSeparatedByString: @"|"];

    for (NSString *iso8601TimeString in iso8601TimeStrings)
    {
        NSDate *date = nil;

        for (NSString *format in legalTimeSpecifierFormats)
        {
            formatter.dateFormat = format;
            date = [formatter dateFromString: iso8601TimeString];

            if (date != nil)
            {
                break;
            }
        }

        if (date != nil)
        {
            NSDate *midnightOnThatDate = date.startOfDay;
            NSTimeInterval secondsSinceMidnight = [date timeIntervalSinceDate: midnightOnThatDate];
            [result addObject: @(secondsSinceMidnight)];
        }
    }
    
    if (result.count == 0)
    {
        result = nil;
    }
    
    return result;
}



// ---------------------------------------------------------
#pragma mark - Utilities
// ---------------------------------------------------------

/**
 Performs a "practical" version of "isEqual", returning YES if
 (a)  both objects are nil, or
 (b)  [object1 isEqual: object2]
 */
- (BOOL) object1: (id) object1
   equalsObject2: (id) object2
{
    return ((object1 == nil && object2 == nil) || [object1 isEqual: object2]);
}

/**
 Returns nil if the specified value is [NSNull null].  Otherwise, returns the
 value itself.

 Used to extract values from an NSDictionary and treat them as "nil" when that
 was the actual intent.
 */
- (id) nilIfNull: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == [NSNull null])
    {
        outputValue = nil;
    }

    return outputValue;
}

/**
 Returns [NSNull null] if the specified value is [NSNull null], so that we can
 insert the specified item into a dictionary.  Otherwise, returns the value
 itself.
 */
- (id) nullIfNil: (id) someInputValue
{
    id outputValue = someInputValue;

    if (outputValue == nil)
    {
        outputValue = [NSNull null];
    }

    return outputValue;
}



@end
